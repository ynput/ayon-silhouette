var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Silhouette Addon","text":"<p>BorisFx Silhouette integration for AYON.</p>"},{"location":"index.html#dev-resources","title":"Dev resources","text":"<ul> <li>Python API: https://documentation.borisfx.com/wiki/sfx/index.php?title=Scripting_Guide</li> </ul>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_silhouette<ul> <li>addon</li> <li>api<ul> <li>lib</li> <li>pipeline</li> <li>plugin</li> <li>workfile_template_builder</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_matte_shapes</li> <li>create_render</li> <li>create_track_points</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>actions</li> <li>load_shapes</li> <li>load_source</li> <li>load_trackpoints</li> </ul> </li> <li>publish<ul> <li>collect_current_document</li> <li>collect_current_file</li> <li>collect_instances</li> <li>collect_workfile</li> <li>extract_render</li> <li>extract_shapes</li> <li>extract_track</li> <li>extract_workfile</li> <li>increment_current_file</li> <li>save_scene</li> <li>validate_shapes</li> <li>validate_trackers</li> </ul> </li> <li>workfile_build<ul> <li>create_placeholder</li> <li>load_placeholder</li> </ul> </li> </ul> </li> <li>startup</li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>imageio</li> <li>main</li> <li>publish</li> <li>templated_workfile_build</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_silhouette/index.html","title":"ayon_silhouette","text":""},{"location":"autoapi/client/ayon_silhouette/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_silhouette/version.html","title":"version","text":"<p>Package declaring AYON addon 'silhouette' version.</p>"},{"location":"autoapi/client/ayon_silhouette/api/index.html","title":"api","text":""},{"location":"autoapi/client/ayon_silhouette/api/index.html#client.ayon_silhouette.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context.\"\"\"\n\n    previous_selection = fx.selection()\n    try:\n        yield\n    finally:\n        fx.select(previous_selection)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html","title":"lib","text":"<p>Library functions for Silhouette.</p>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.capture_messageboxes","title":"<code>capture_messageboxes(callback)</code>","text":"<p>Capture messageboxes and call a callback with them.</p> <p>This is a workaround for Silhouette not allowing the Python code to suppress messageboxes and supply default answers to them. So instead we capture the messageboxes and respond to them through a rapid QTimer.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef capture_messageboxes(callback):\n    \"\"\"Capture messageboxes and call a callback with them.\n\n    This is a workaround for Silhouette not allowing the Python code to\n    suppress messageboxes and supply default answers to them. So instead we\n    capture the messageboxes and respond to them through a rapid QTimer.\n    \"\"\"\n    processed = set()\n    timer = QtCore.QTimer()\n\n    def on_timeout():\n        # Check for dialogs\n        widgets = QtWidgets.QApplication.instance().topLevelWidgets()\n        has_boxes = False\n        for widget in widgets:\n            if isinstance(widget, QtWidgets.QMessageBox):\n                has_boxes = True\n                if widget in processed:\n                    continue\n                processed.add(widget)\n                callback(widget)\n\n        # Stop as soon as possible with our detections. Even with the\n        # QTimer repeating at interval of 0 we should have been able to\n        # capture all the UI events as they happen in the main thread for\n        # each dialog.\n        # Note: Technically this would mean that as soon as there is no\n        # active messagebox we directly stop the timer, and hence would stop\n        # finding messageboxes after. However, with the export methods in\n        # Silhouette this has not been a problem and all boxes were detected\n        # accordingly.\n        if not has_boxes:\n            timer.stop()\n\n    timer.setSingleShot(False)  # Allow to capture multiple boxes\n    timer.timeout.connect(on_timeout)\n    timer.start()\n    try:\n        yield\n    finally:\n        timer.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.collect_animation_defs","title":"<code>collect_animation_defs(create_context, fps=False)</code>","text":"<p>Get the basic animation attribute definitions for the publisher.</p> <p>Parameters:</p> Name Type Description Default <code>create_context</code> <code>CreateContext</code> <p>The context of publisher will be used to define the defaults for the attributes to use the current context's entity frame range as default values.</p> required <code>step</code> <code>bool</code> <p>Whether to include <code>step</code> attribute definition.</p> required <code>fps</code> <code>bool</code> <p>Whether to include <code>fps</code> attribute definition.</p> <code>False</code> <p>Returns:</p> Type Description <p>List[NumberDef]: List of number attribute definitions.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def collect_animation_defs(create_context, fps=False):\n    \"\"\"Get the basic animation attribute definitions for the publisher.\n\n    Arguments:\n        create_context (CreateContext): The context of publisher will be\n            used to define the defaults for the attributes to use the current\n            context's entity frame range as default values.\n        step (bool): Whether to include `step` attribute definition.\n        fps (bool): Whether to include `fps` attribute definition.\n\n    Returns:\n        List[NumberDef]: List of number attribute definitions.\n\n    \"\"\"\n\n    # use task entity attributes to set defaults based on current context\n    task_entity = create_context.get_current_task_entity()\n    attrib: dict = task_entity[\"attrib\"]\n    frame_start: int = attrib[\"frameStart\"]\n    frame_end: int = attrib[\"frameEnd\"]\n    handle_start: int = attrib[\"handleStart\"]\n    handle_end: int = attrib[\"handleEnd\"]\n\n    # build attributes\n    defs = [\n        NumberDef(\"frameStart\",\n                  label=\"Frame Start\",\n                  default=frame_start,\n                  decimals=0),\n        NumberDef(\"frameEnd\",\n                  label=\"Frame End\",\n                  default=frame_end,\n                  decimals=0),\n        NumberDef(\"handleStart\",\n                  label=\"Handle Start\",\n                  tooltip=\"Frames added before frame start to use as handles.\",\n                  default=handle_start,\n                  decimals=0),\n        NumberDef(\"handleEnd\",\n                  label=\"Handle End\",\n                  tooltip=\"Frames added after frame end to use as handles.\",\n                  default=handle_end,\n                  decimals=0),\n    ]\n\n    # if fps:\n    #     doc = active_document()\n    #     current_fps = doc.GetFps()\n    #     fps_def = NumberDef(\n    #         \"fps\", label=\"FPS\", default=current_fps, decimals=5\n    #     )\n    #     defs.append(fps_def)\n\n    return defs\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.copy_session_nodes","title":"<code>copy_session_nodes(source_session, destination_session)</code>","text":"<p>Merge all nodes from source session into destination session.</p> <p>Parameters:</p> Name Type Description Default <code>source_session</code> <code>Session</code> <p>The source session to clone nodes from.</p> required <code>destination_session</code> <code>Session</code> <p>The destination session to merge into.</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[fx.Node]: The cloned nodes in the destination session.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def copy_session_nodes(\n        source_session: fx.Session,\n        destination_session: fx.Session) -&gt; List[fx.Node]:\n    \"\"\"Merge all nodes from source session into destination session.\n\n    Arguments:\n        source_session (fx.Session): The source session to clone nodes from.\n        destination_session (fx.Session): The destination session to merge\n            into.\n\n    Returns:\n        List[fx.Node]: The cloned nodes in the destination session.\n    \"\"\"\n    connections = {}\n    for node in source_session.nodes:\n        # We skip outputs because we are iterating all nodes\n        # so we could automatically also collect the outputs if we\n        # collect all their inputs\n        connections.update(get_connections(node, outputs=False))\n\n    # Create clones of the nodes from the source session\n    source_node_to_clone_node: Dict[fx.Node, fx.Node] = {\n        node: node.clone() for node in source_session.nodes\n    }\n\n    # Add all clones to the destination session\n    for node in source_node_to_clone_node.values():\n        destination_session.addNode(node)\n\n    # Re-apply all their connections\n    for destination, source in connections.items():\n        source_node = source_node_to_clone_node[source.node]\n        destination_node = source_node_to_clone_node[destination.node]\n        source_port = get_output_port_by_name(source_node,\n                                              source.name)\n        destination_port = get_input_port_by_name(destination_node,\n                                                  destination.name)\n        source_port.connect(destination_port)\n\n    return list(source_node_to_clone_node.values())\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.get_connections","title":"<code>get_connections(node, inputs=True, outputs=True)</code>","text":"<p>Return connections from destination ports to their source ports.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def get_connections(\n    node: fx.Node,\n    inputs=True,\n    outputs=True) -&gt; Dict[fx.Port, fx.Port]:\n    \"\"\"Return connections from destination ports to their source ports.\"\"\"\n    connections: Dict[fx.Port, fx.Port] = {}\n    if inputs:\n        for input_destination in node.connectedInputs:\n            connections[input_destination] = input_destination.source\n    if outputs:\n        for output_source in node.connectedOutputs:\n            for target_destination in output_source.targets:\n                connections[target_destination] = output_source\n    return connections\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.get_input_port_by_name","title":"<code>get_input_port_by_name(node, port_name)</code>","text":"<p>Return the input port with the given name.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def get_input_port_by_name(node: fx.Node, port_name: str) -&gt; Optional[fx.Port]:\n    \"\"\"Return the input port with the given name.\"\"\"\n    return next(\n        (port for port in node.inputs if port.name == port_name),\n        None\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.get_main_window","title":"<code>get_main_window()</code>","text":"<p>Get the main Qt window of the application.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def get_main_window():\n    \"\"\"Get the main Qt window of the application.\"\"\"\n    return tools.window.get_main_window()\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.get_output_port_by_name","title":"<code>get_output_port_by_name(node, port_name)</code>","text":"<p>Return the output port with the given name.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def get_output_port_by_name(\n        node: fx.Node, port_name: str) -&gt; Optional[fx.Port]:\n    \"\"\"Return the output port with the given name.\"\"\"\n    return next(\n        (port for port in node.outputs if port.name == port_name),\n        None\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.import_project","title":"<code>import_project(path, merge_sessions=True)</code>","text":"<p>Import Silhouette project into current project.</p> <p>Silhouette can't 'import' projects natively, so instead we will use our own logic to load the content from a project file into the currently active project.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The project path to import. Since Silhouette projects are folders this should be the path to the project folder.</p> required <code>merge_sessions</code> <code>bool</code> <p>When enabled, sessions with the same label will be 'merged' by adding all nodes of the imported session to the existing session.</p> <code>True</code> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>@undo_chunk(\"Import project\")\ndef import_project(\n    path,\n    merge_sessions=True):\n    \"\"\"Import Silhouette project into current project.\n\n    Silhouette can't 'import' projects natively, so instead we will use our\n    own logic to load the content from a project file into the currently\n    active project.\n\n    Arguments:\n        path (str): The project path to import. Since Silhouette projects\n            are folders this should be the path to the project folder.\n        merge_sessions (bool): When enabled, sessions with the same label\n            will be 'merged' by adding all nodes of the imported session to\n            the existing session.\n\n    \"\"\"\n    original_project = fx.activeProject()\n    if not original_project:\n        # Open a project\n        original_project = fx.Project()\n        fx.setActiveProject(original_project)\n\n    merge_project = fx.loadProject(path)\n\n    # Revert to original project\n    fx.setActiveProject(original_project)\n\n    # Add sources from the other project\n    for source in merge_project.sources:\n        original_project.addItem(source)\n\n    # Merge sessions by label if there's a matching one\n    sessions_by_label = {\n        session.label: session for session in original_project.sessions\n    }\n    for merge_session in merge_project.sessions:\n        if merge_sessions and merge_session.label in sessions_by_label:\n            original_session = sessions_by_label[merge_session.label]\n            copy_session_nodes(merge_session, original_session)\n        else:\n            # Add the session\n            original_project.addItem(merge_session.clone())\n\n            # For niceness - set it as active session if current project has\n            # no active session\n            if not fx.activeSession():\n                fx.setActiveSession(merge_session)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.imprint","title":"<code>imprint(node, data, key='AYON')</code>","text":"<p>Write <code>data</code> to <code>node</code> as userDefined attributes</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Object | Node</code> <p>The selection object</p> required <code>data</code> <code>dict</code> <p>Dictionary of key/value pairs</p> required Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def imprint(node, data: Optional[dict], key=\"AYON\"):\n    \"\"\"Write `data` to `node` as userDefined attributes\n\n    Arguments:\n        node (fx.Object | fx.Node): The selection object\n        data (dict): Dictionary of key/value pairs\n    \"\"\"\n    if isinstance(node, fx.Node):\n        return imprint_state(node, data, key)\n    elif isinstance(node, fx.Object):\n        return imprint_property(node, data, key)\n    else:\n        raise TypeError(f\"Unsupported node type: {node} ({type(node)})\")\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.iter_children","title":"<code>iter_children(node, prefix=None)</code>","text":"<p>Iterate over all children of a node recursively.</p> <p>This yields the node together with a label that indicates the full path from the root node passed to the function.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def iter_children(\n        node: fx.Node,\n        prefix: Optional[str] = None\n) -&gt; Iterator[Tuple[fx.Node, str]]:\n    \"\"\"Iterate over all children of a node recursively.\n\n    This yields the node together with a label that indicates the full path\n    from the root node passed to the function.\n    \"\"\"\n    children = node.children\n    if not children:\n        return\n    for child in reversed(children):\n        # Yield with a nested label so we can easily display it nicely\n        label = child.label\n        if prefix:\n            label = f\"{prefix} &gt; {label}\"\n        yield child, label\n        yield from iter_children(child, prefix=label)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context.\"\"\"\n\n    previous_selection = fx.selection()\n    try:\n        yield\n    finally:\n        fx.select(previous_selection)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.read","title":"<code>read(node, key='AYON')</code>","text":"<p>Return user-defined attributes from <code>node</code></p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Object | Node</code> <p>Node or object to redad from.</p> required <code>key</code> <code>str</code> <p>The key to read from.</p> <code>'AYON'</code> <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Optional[dict]: The data stored in the node.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def read(node, key=\"AYON\") -&gt; Optional[dict]:\n    \"\"\"Return user-defined attributes from `node`\n\n    Arguments:\n        node (fx.Object | fx.Node): Node or object to redad from.\n        key (str): The key to read from.\n\n    Returns:\n        Optional[dict]: The data stored in the node.\n\n    \"\"\"\n    if isinstance(node, fx.Node):\n        # Use node state instead of property\n        return read_state(node, key)\n    elif isinstance(node, fx.Object):\n        # Project or source items do not have state\n        return read_property(node, key)\n    else:\n        raise TypeError(f\"Unsupported node type: {node} ({type(node)})\")\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.reset_session_settings","title":"<code>reset_session_settings(session=None, task_entity=None)</code>","text":"<p>Reset the session settings to the task context defaults.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def reset_session_settings(session=None, task_entity=None):\n    \"\"\"Reset the session settings to the task context defaults.\"\"\"\n    if session is None:\n        session = fx.activeSession()\n        assert session\n\n    if task_entity is None:\n        task_entity = get_current_task_entity()\n\n    with undo_chunk(\"Reset session settings\"):\n        set_resolution_from_entity(session, task_entity)\n        set_frame_range_from_entity(session, task_entity)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.set_frame_range_from_entity","title":"<code>set_frame_range_from_entity(session, task_entity)</code>","text":"<p>Set frame range and FPS from task entity attributes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>The Silhouette session.</p> required <code>task_entity</code> <code>dict</code> <p>Task entity.</p> required Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def set_frame_range_from_entity(session, task_entity):\n    \"\"\"Set frame range and FPS from task entity attributes.\n\n    Args:\n        session (fx.Session): The Silhouette session.\n        task_entity (dict): Task entity.\n\n    \"\"\"\n    frame_start = task_entity[\"attrib\"][\"frameStart\"]\n    frame_end = task_entity[\"attrib\"][\"frameEnd\"]\n    fps = task_entity[\"attrib\"][\"fps\"]\n\n    with undo_chunk(\"Set session frame range\"):\n        session.frameRate = fps\n        session.startFrame = frame_start\n        session.duration = (frame_end - frame_start) + 1\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.set_new_node_position","title":"<code>set_new_node_position(node)</code>","text":"<p>Position the node near the active node, or the top-right of the scene</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def set_new_node_position(node):\n    \"\"\"Position the node near the active node, or the top-right of the scene\"\"\"\n    n = fx.activeNode()\n    if n:\n        pos = fx.trees.nextPos(n)\n    else:\n        bounds = fx.trees.bounds\n        size = fx.trees.nodeSize(node)\n        pos = fx.Point(\n            bounds.right - size.x / 2,\n            bounds.top + size.y / 2\n        )\n    node.setState(\"graph.pos\", pos)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.set_resolution_from_entity","title":"<code>set_resolution_from_entity(session, task_entity)</code>","text":"<p>Set resolution and pixel aspect from task entity attributes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>The Silhouette session.</p> required <code>task_entity</code> <code>dict</code> <p>Task entity.</p> required Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def set_resolution_from_entity(session, task_entity):\n    \"\"\"Set resolution and pixel aspect from task entity attributes.\n\n    Args:\n        session (fx.Session): The Silhouette session.\n        task_entity (dict): Task entity.\n\n    \"\"\"\n    task_attrib = task_entity[\"attrib\"]\n    with undo_chunk(\"Set session resolution\"):\n        session.width = task_attrib[\"resolutionWidth\"]\n        session.height = task_attrib[\"resolutionHeight\"]\n        session.pixelAspect = task_attrib[\"pixelAspect\"]\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.transfer_connections","title":"<code>transfer_connections(source, destination, inputs=True, outputs=True)</code>","text":"<p>Transfer connections from one node to another.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>@undo_chunk(\"Transfer connections\")\ndef transfer_connections(\n    source: fx.Node,\n    destination: fx.Node,\n    inputs: bool = True,\n    outputs: bool = True):\n    \"\"\"Transfer connections from one node to another.\"\"\"\n    # TODO: Match port by something else than name? (e.g. idx?)\n    # Transfer connections from inputs\n    if inputs:\n        for _input in source.connectedInputs:\n            name = _input.name\n            destination_input = get_input_port_by_name(destination, name)\n            if destination_input:\n                destination_input.disconnect()\n                _input.source.connect(destination_input)\n\n    # Transfer connections from outputs\n    if outputs:\n        for output in source.connectedOutputs:\n            name = output.name\n            destination_output = get_output_port_by_name(destination, name)\n            if destination_output:\n                for target in output.targets:\n                    target.disconnect()\n                    destination_output.connect(target)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.undo_chunk","title":"<code>undo_chunk(label='')</code>","text":"<p>Open undo chunk during context.</p> <p>In Silhouette, it's often necessary to group operations into an undo chunk to ensure the UI updates correctly on property and value changes.</p> <p>Note that <code>contextlib.contextmanager</code> can also be used as function decorators.</p> Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef undo_chunk(label=\"\"):\n    \"\"\"Open undo chunk during context.\n\n    In Silhouette, it's often necessary to group operations into an undo chunk\n    to ensure the UI updates correctly on property and value changes.\n\n    Note that `contextlib.contextmanager` can also be used as function\n    decorators.\n\n    \"\"\"\n    try:\n        fx.beginUndo(label)\n        yield\n    finally:\n        fx.endUndo()\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.unzip","title":"<code>unzip(source, destination)</code>","text":"<p>Unzip a zip file to destination.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Zip file to extract.</p> required <code>destination</code> <code>str</code> <p>Destination directory to extract to.</p> required Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def unzip(source, destination):\n    \"\"\"Unzip a zip file to destination.\n\n    Args:\n        source (str): Zip file to extract.\n        destination (str): Destination directory to extract to.\n\n    \"\"\"\n    with _ZipFile(source) as zr:\n        zr.extractall(destination)\n    log.debug(f\"Extracted '{source}' to '{destination}'\")\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/lib.html#client.ayon_silhouette.api.lib.zip_folder","title":"<code>zip_folder(source, destination)</code>","text":"<p>Zip a directory and move to <code>destination</code>.</p> <p>This zips the contents of the source directory into the zip file. The source directory itself is not included in the zip file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Directory to zip and move to destination.</p> required <code>destination</code> <code>str</code> <p>Destination file path to zip file.</p> required Source code in <code>client/ayon_silhouette/api/lib.py</code> <pre><code>def zip_folder(source, destination):\n    \"\"\"Zip a directory and move to `destination`.\n\n    This zips the contents of the source directory into the zip file. The\n    source directory itself is not included in the zip file.\n\n    Args:\n        source (str): Directory to zip and move to destination.\n        destination (str): Destination file path to zip file.\n\n    \"\"\"\n    def _iter_zip_files_mapping(start):\n        for root, dirs, files in os.walk(start):\n            for folder in dirs:\n                path = os.path.join(root, folder)\n                yield path, os.path.relpath(path, start)\n            for file in files:\n                path = os.path.join(root, file)\n                yield path, os.path.relpath(path, start)\n\n    if not os.path.isdir(source):\n        raise ValueError(f\"Source is not a directory: {source}\")\n\n    if os.path.exists(destination):\n        os.remove(destination)\n\n    with _ZipFile(\n        destination, \"w\", zipfile.ZIP_DEFLATED\n    ) as zr:\n        for path, relpath in _iter_zip_files_mapping(source):\n            zr.write(path, relpath)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_silhouette/api/pipeline.html#client.ayon_silhouette.api.pipeline.defer","title":"<code>defer(callable, timeout=0)</code>","text":"<p>Defer a callable to the next event loop.</p> Source code in <code>client/ayon_silhouette/api/pipeline.py</code> <pre><code>def defer(callable, timeout=0):\n    \"\"\"Defer a callable to the next event loop.\"\"\"\n    QtCore.QTimer.singleShot(timeout, callable)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/pipeline.html#client.ayon_silhouette.api.pipeline.iter_containers","title":"<code>iter_containers(project=None, session=None)</code>","text":"<p>Yield all source objects in the active project with AYON property AYON container ID</p> Source code in <code>client/ayon_silhouette/api/pipeline.py</code> <pre><code>def iter_containers(project=None, session=None):\n    \"\"\"Yield all source objects in the active project with AYON property\n     AYON container ID\"\"\"\n\n    if project is None:\n        project = fx.activeProject()\n\n    if not project:\n        return\n\n    # List all sources in project with `AYON` property\n    for source in project.sources:\n        data = parse_container(source, project=project)\n        if data:\n            yield data\n\n    if session is None:\n        session = fx.activeSession()\n\n    if not session:\n        return\n\n    # List all nodes in session with `AYON` property\n    for node in session.nodes:\n        data = parse_container(node, project=project, session=session)\n        if data:\n            yield data\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/pipeline.html#client.ayon_silhouette.api.pipeline.iter_instances","title":"<code>iter_instances(session=None)</code>","text":"<p>Yield all objects in the active session that have 'id' attribute set matching an AYON container ID</p> Source code in <code>client/ayon_silhouette/api/pipeline.py</code> <pre><code>def iter_instances(session=None):\n    \"\"\"Yield all objects in the active session that have 'id' attribute set\n    matching an AYON container ID\"\"\"\n\n    if session is None:\n        session = fx.activeSession()\n    if not session:\n        return\n\n    for node in session.nodes:\n        data = lib.read(node)\n        if data and data.get(\"id\") == AYON_INSTANCE_ID:\n            data[\"_node\"] = node\n            yield data\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/pipeline.html#client.ayon_silhouette.api.pipeline.parse_container","title":"<code>parse_container(source, project=None, session=None)</code>","text":"<p>Return the container node's full container data.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source | Node</code> <p>A Silhouette source or node.</p> required <code>project</code> <code>Optional[Project]</code> <p>Project related to the source item or node so that we can track it back to the project.</p> <code>None</code> <code>session</code> <code>Optional[Session]</code> <p>Session related to the source item or node so that we can track it back to the session.</p> <code>None</code> <p>Returns:</p> Type Description <p>dict[str, Any]: The container schema data for this container node.</p> Source code in <code>client/ayon_silhouette/api/pipeline.py</code> <pre><code>def parse_container(source, project=None, session=None):\n    \"\"\"Return the container node's full container data.\n\n    Args:\n        source (fx.Source | fx.Node): A Silhouette source or node.\n        project (Optional[fx.Project]): Project related to the source\n            item or node so that we can track it back to the project.\n        session (Optional[fx.Session]): Session related to the source\n            item or node so that we can track it back to the session.\n\n    Returns:\n        dict[str, Any]: The container schema data for this container node.\n\n    \"\"\"\n    data = lib.read(source)\n    if not data:\n        return\n\n    # TODO: ensure object is actually a container by `id` value\n\n    # Backwards compatibility pre-schemas for containers\n    data[\"schema\"] = data.get(\"schema\", \"ayon:container-3.0\")\n    data[\"objectName\"] = source.label  # required for container data model\n\n    # Append transient data\n    data[\"_item\"] = source\n    if project is not None:\n        data[\"_project\"] = project\n    if session is not None:\n        data[\"_session\"] = session\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_silhouette/api/plugin.html#client.ayon_silhouette.api.plugin.SilhouetteCreator","title":"<code>SilhouetteCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Base class for Silhouette creators.</p> <p>This base creator can be applied multiple times to a single node, where each instance is stored as a separate imprint on the node, inside an <code>AYON_instances</code> state that is a <code>dict[str, dict]</code> of instance data per uuid. The <code>instance_id</code> will then be defined by the node's id and this uuid as <code>{node_id}|{uuid}</code>.</p> <p>This way, a single RotoNode can have multiple instances of different product types (or even the same product type) to allow exporting e.g. track points and matte shapes from the same RotoNode.</p> Source code in <code>client/ayon_silhouette/api/plugin.py</code> <pre><code>class SilhouetteCreator(Creator):\n    \"\"\"Base class for Silhouette creators.\n\n    This base creator can be applied multiple times to a single node, where\n    each instance is stored as a separate imprint on the node, inside an\n    `AYON_instances` state that is a `dict[str, dict]` of instance data per\n    uuid. The `instance_id` will then be defined by the node's id and this uuid\n    as `{node_id}|{uuid}`.\n\n    This way, a single RotoNode can have multiple instances of different\n    product types (or even the same product type) to allow exporting e.g.\n    track points and matte shapes from the same RotoNode.\n\n    \"\"\"\n    default_variants = [\"Main\"]\n    settings_category = \"silhouette\"\n\n    create_node_type = \"OutputNode\"\n\n    # When `valid_node_types` is set, all these node types are allowed to get\n    # imprinted by this creator\n    valid_node_types = set()\n\n    @lib.undo_chunk(\"Create instance\")\n    def create(self, product_name, instance_data, pre_create_data):\n\n        session = fx.activeSession()\n        if not session:\n            return\n\n        instance_node = None\n        use_selection = pre_create_data.get(\"use_selection\")\n        selected_nodes = []\n        if use_selection:\n            # Allow to imprint on a currently selected node of the same type\n            # as this creator would generate. If the node is already imprinted\n            # by a Creator then raise an error - otherwise use it as the\n            # instance node.\n            valid_node_types = self.valid_node_types or {self.create_node_type}\n            selected_nodes = [\n                node for node in fx.selection() if isinstance(node, fx.Node)]\n            for node in selected_nodes:\n                if node.type in valid_node_types:\n                    data = lib.read(node)\n                    if data and data.get(\"creator_identifier\"):\n                        raise CreatorError(\n                            \"Selected node is already imprinted by a Creator.\"\n                        )\n                    instance_node = node\n                    self.log.info(\n                        f\"Using selected node as instance node: {node.label}\")\n                    break\n\n        if instance_node is None:\n            # Create new node and place it in the scene\n            instance_node = fx.Node(self.create_node_type)\n            session.addNode(instance_node)\n            lib.set_new_node_position(instance_node)\n\n            # When generating a new instance node and use selection is enabled,\n            # connect to the first selected node with a matching output type\n            if use_selection and selected_nodes:\n                self._connect_input_to_first_matching_candidate(\n                    instance_node, selected_nodes)\n\n            instance_node.label = session.uniqueLabel(product_name)\n        fx.activate(instance_node)\n\n        # Use the uniqueness of the node in Silhouette as part of the instance\n        # id, but because we support multiple instances per node, we also add\n        # an uuid within the node to make duplicates of nodes still unique in\n        # the full create context.\n        instance_id = f\"{instance_node.id}|{uuid.uuid4()}\"\n        instance_data[\"instance_id\"] = instance_id\n        instance_data[\"label\"] = self._define_label(\n            instance_node, product_name)\n        instance = CreatedInstance(\n            product_type=self.product_type,\n            product_name=product_name,\n            data=instance_data,\n            creator=self,\n            transient_data={\n                \"instance_node\": instance_node\n            }\n        )\n\n        # Store the instance data\n        data = instance.data_to_store()\n        self._imprint(instance_node, data)\n\n        self._add_instance_to_context(instance)\n\n        return instance\n\n    def collect_instances(self):\n        shared_data = cache_instance_data(self.collection_shared_data)\n        cached_instances = shared_data[\"silhouette_cached_instances\"]\n        for obj, instance_uuid, data in cached_instances.get(\n                self.identifier, []):\n            data[\"instance_id\"] = f\"{obj.id}|{instance_uuid}\"\n            data[\"label\"] = self._define_label(obj, data[\"productName\"])\n\n            # Add instance\n            created_instance = CreatedInstance.from_existing(\n                data,\n                self,\n                transient_data={\"instance_node\": obj}\n            )\n            self._add_instance_to_context(created_instance)\n\n    @lib.undo_chunk(\"Update instances\")\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n            new_data = created_inst.data_to_store()\n            node = created_inst.transient_data[\"instance_node\"]\n            self._imprint(node, new_data)\n\n    @lib.undo_chunk(\"Remove instances\")\n    def remove_instances(self, instances):\n        for instance in instances:\n\n            # Remove node from the scene\n            node = instance.transient_data[\"instance_node\"]\n            if node:\n                instance_uuid = self._get_uuid_from_instance_id(instance.id)\n                instances_by_uuid = lib.read(node,\n                                             key=INSTANCES_DATA_KEY) or {}\n                instances_by_uuid.pop(instance_uuid, None)\n                if not instances_by_uuid:\n                    # Remove the node, because it was the last imprinted value\n                    session = node.session\n                    session.removeNode(node)\n                else:\n                    # Update the node's imprinted value by removing the entry\n                    lib.imprint(\n                        node,\n                        instances_by_uuid,\n                        key=INSTANCES_DATA_KEY)\n\n            # Remove the collected CreatedInstance to remove from UI directly\n            self._remove_instance_from_context(instance)\n\n    def _imprint(self, node, data):\n        data.pop(\"label\", None)  # do not store the label\n        # Do not store instance id since it's the Silhouette node id\n        instance_id = data.pop(\"instance_id\")\n\n        instance_uuid = self._get_uuid_from_instance_id(instance_id)\n        instances_by_uuid = lib.read(node, key=INSTANCES_DATA_KEY) or {}\n        instances_by_uuid[instance_uuid] = data\n        lib.imprint(node, instances_by_uuid, key=INSTANCES_DATA_KEY)\n\n    def _get_uuid_from_instance_id(self, instance_id: str) -&gt; str:\n        \"\"\"Return uuid for instance's key on the node data from instance id.\"\"\"\n        return instance_id.rsplit(\"|\", 1)[-1]\n\n    def _define_label(self, obj: fx.Node, product_name: str) -&gt; str:\n        return f\"{product_name} ({obj.label})\"\n\n    def get_pre_create_attr_defs(self):\n        return [\n            BoolDef(\"use_selection\",\n                    label=\"Use selection\",\n                    default=True)\n        ]\n\n    def _connect_input_to_first_matching_candidate(self, node, candidates):\n        \"\"\"Connect the primary input of `node` to the first candidate with\n        an output that has a matching data type.\"\"\"\n        primary_input = node.primaryInput\n        if not primary_input:\n            return\n\n        allowed_types = set(primary_input.dataTypes)\n        for candidate in candidates:\n            for output in candidate.outputs:\n                if allowed_types.intersection(output.dataTypes):\n                    output.connect(primary_input)\n                    return\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/plugin.html#client.ayon_silhouette.api.plugin.SilhouetteImportLoader","title":"<code>SilhouetteImportLoader</code>","text":"<p>               Bases: <code>SilhouetteLoader</code></p> <p>Import using the chosen Silhouette IO module.</p> Source code in <code>client/ayon_silhouette/api/plugin.py</code> <pre><code>class SilhouetteImportLoader(SilhouetteLoader):\n    \"\"\"Import using the chosen Silhouette IO module.\"\"\"\n    # TODO: Should we allow importing multiple containers to one node?\n    #  It may be needed for importing both track points and matte shapes to\n    #  a single RotoNode\n\n    io_module: str\n    node_type = \"RotoNode\"\n\n    options = [\n        BoolDef(\n            \"use_selection\",\n            label=\"Use selection\",\n            default=True,\n            tooltip=(\n                \"Use the selected node if it supports the import type. \"\n                \"Otherwise create a new node.\"\n            )\n        )\n    ]\n\n    @lib.undo_chunk(\"Load\")\n    @lib.maintained_selection()\n    def load(self, context, name=None, namespace=None, options=None):\n        \"\"\"Merge the Alembic into the scene.\"\"\"\n        if not fx.activeProject():\n            raise RuntimeError(\"No active project found.\")\n        if not fx.activeSession():\n            raise RuntimeError(\"No active session found.\")\n        if options is None:\n            options = {}\n\n        # Use selected node or create a new one to import to\n        selection = [\n            _node for _node in fx.selection() if self.can_import_to_node(_node)\n        ]\n        if options.get(\"use_selection\", True) and selection:\n            node = selection[0]\n        else:\n            # Create a new node\n            node = fx.Node(self.node_type)\n            fx.activeSession().addNode(node)\n            lib.set_new_node_position(node)\n\n\n        # Import the file\n        fx.activate(node)\n        filepath = self.filepath_from_context(context)\n\n        try:\n            fx.io_modules[self.io_module].importFile(filepath)\n        except AssertionError as exc:\n            # Provide better message than \"importer not ready\" when it fails\n            # to import\n            if str(exc) == \"importer not ready\":\n                raise LoadError(\n                    f\"Failed to import as '{self.io_module}':\\n{filepath}\"\n                    f\"\\n\\n\"\n                    f\"Most likely the Tracker format is unsupported.\"\n                ) from exc\n            raise\n        self._process_loaded(context, node)\n\n        # property.hidden = True  # hide the attribute\n        lib.imprint(node, data={\n            \"name\": str(name),\n            \"namespace\": str(namespace),\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n        })\n\n    def _process_loaded(self, context, node):\n        # For overrides on inherited classes\n        pass\n\n    @lib.undo_chunk(\"Update Source\")\n    @lib.maintained_selection()\n    def update(self, container, context):\n        item: fx.Node = container[\"_item\"]\n\n        # Remove existing children\n        item.objects.removeObjects(item.children)\n\n        # Import the file\n        fx.activate(item)\n        filepath = self.filepath_from_context(context)\n        fx.io_modules[self.io_module].importFile(filepath)\n\n        # Update representation id\n        data = lib.read(item)\n        data[\"representation\"] = context[\"representation\"][\"id\"]\n        lib.imprint(item, data)\n\n    @lib.undo_chunk(\"Remove container\")\n    def remove(self, container):\n        \"\"\"Remove node from session\"\"\"\n        node: fx.Node = container[\"_item\"]\n        session = container[\"_session\"]\n        session.removeNode(node)\n\n    def switch(self, container, context):\n        \"\"\"Support switch to another representation.\"\"\"\n        self.update(container, context)\n\n    def can_import_to_node(self, node) -&gt; bool:\n\n        if isinstance(node, fx.Node):\n            return True\n\n        # Do not allow load to node that already has import\n        # TODO: Support multiple containers per node\n        if parse_container(node):\n            return False\n\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/plugin.html#client.ayon_silhouette.api.plugin.SilhouetteImportLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Merge the Alembic into the scene.</p> Source code in <code>client/ayon_silhouette/api/plugin.py</code> <pre><code>@lib.undo_chunk(\"Load\")\n@lib.maintained_selection()\ndef load(self, context, name=None, namespace=None, options=None):\n    \"\"\"Merge the Alembic into the scene.\"\"\"\n    if not fx.activeProject():\n        raise RuntimeError(\"No active project found.\")\n    if not fx.activeSession():\n        raise RuntimeError(\"No active session found.\")\n    if options is None:\n        options = {}\n\n    # Use selected node or create a new one to import to\n    selection = [\n        _node for _node in fx.selection() if self.can_import_to_node(_node)\n    ]\n    if options.get(\"use_selection\", True) and selection:\n        node = selection[0]\n    else:\n        # Create a new node\n        node = fx.Node(self.node_type)\n        fx.activeSession().addNode(node)\n        lib.set_new_node_position(node)\n\n\n    # Import the file\n    fx.activate(node)\n    filepath = self.filepath_from_context(context)\n\n    try:\n        fx.io_modules[self.io_module].importFile(filepath)\n    except AssertionError as exc:\n        # Provide better message than \"importer not ready\" when it fails\n        # to import\n        if str(exc) == \"importer not ready\":\n            raise LoadError(\n                f\"Failed to import as '{self.io_module}':\\n{filepath}\"\n                f\"\\n\\n\"\n                f\"Most likely the Tracker format is unsupported.\"\n            ) from exc\n        raise\n    self._process_loaded(context, node)\n\n    # property.hidden = True  # hide the attribute\n    lib.imprint(node, data={\n        \"name\": str(name),\n        \"namespace\": str(namespace),\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/plugin.html#client.ayon_silhouette.api.plugin.SilhouetteImportLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove node from session</p> Source code in <code>client/ayon_silhouette/api/plugin.py</code> <pre><code>@lib.undo_chunk(\"Remove container\")\ndef remove(self, container):\n    \"\"\"Remove node from session\"\"\"\n    node: fx.Node = container[\"_item\"]\n    session = container[\"_session\"]\n    session.removeNode(node)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/plugin.html#client.ayon_silhouette.api.plugin.SilhouetteImportLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Support switch to another representation.</p> Source code in <code>client/ayon_silhouette/api/plugin.py</code> <pre><code>def switch(self, container, context):\n    \"\"\"Support switch to another representation.\"\"\"\n    self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/plugin.html#client.ayon_silhouette.api.plugin.cache_instance_data","title":"<code>cache_instance_data(shared_data)</code>","text":"<p>Cache instances for Creators shared data.</p> <p>Create <code>silhouette_cached_instances</code> key when needed in shared data and fill it with all collected instances from the scene under its respective creator identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>shared_data(Dict[str,</code> <code>Any]</code> <p>Shared data.</p> required Source code in <code>client/ayon_silhouette/api/plugin.py</code> <pre><code>def cache_instance_data(shared_data):\n    \"\"\"Cache instances for Creators shared data.\n\n    Create `silhouette_cached_instances` key when needed in shared data and\n    fill it with all collected instances from the scene under its\n    respective creator identifiers.\n\n    Args:\n        shared_data(Dict[str, Any]): Shared data.\n\n    \"\"\"\n    if shared_data.get('silhouette_cached_instances') is None:\n        shared_data[\"silhouette_cached_instances\"] = cache = {}\n\n        session = fx.activeSession()\n        if not session:\n            return cache\n\n        for node in session.nodes:\n            instances_data_by_uuid = lib.read(node, key=INSTANCES_DATA_KEY)\n            if not instances_data_by_uuid:\n                continue\n\n            for instance_uuid, data in instances_data_by_uuid.items():\n                if data.get(\"id\") != AYON_INSTANCE_ID:\n                    continue\n\n                creator_id = data.get(\"creator_identifier\")\n                if not creator_id:\n                    continue\n\n                cache.setdefault(creator_id, []).append(\n                    (node, instance_uuid, data))\n\n    return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/workfile_template_builder.html","title":"workfile_template_builder","text":""},{"location":"autoapi/client/ayon_silhouette/api/workfile_template_builder.html#client.ayon_silhouette.api.workfile_template_builder.SilhouettePlaceholderPlugin","title":"<code>SilhouettePlaceholderPlugin</code>","text":"<p>               Bases: <code>PlaceholderPlugin</code></p> Source code in <code>client/ayon_silhouette/api/workfile_template_builder.py</code> <pre><code>class SilhouettePlaceholderPlugin(PlaceholderPlugin):\n    data_key = \"ayon.placeholder\"\n    item_class = PlaceholderItem\n\n    def _create_placeholder_node(\n            self, placeholder_data, session, node_type=\"NullNode\"):\n        # Create node\n        placeholder_node = fx.Node(node_type)\n        placeholder_node.label = \"PLACEHOLDER\"\n        session.addNode(placeholder_node)\n        lib.set_new_node_position(placeholder_node)\n        return placeholder_node\n\n    @lib.undo_chunk(\"Create placeholder\")\n    def create_placeholder(self, placeholder_data) -&gt; PlaceholderItem:\n        session = fx.activeSession()\n        if not session:\n            raise RuntimeError(\"Must have active session.\")\n\n        placeholder_data[\"plugin_identifier\"] = self.identifier\n\n        placeholder_node = self._create_placeholder_node(\n            placeholder_data, session)\n\n        fx.activate(placeholder_node)\n\n        imprint(placeholder_node, placeholder_data, key=self.data_key)\n\n        item = self.item_class(\n            scene_identifier=placeholder_node.id,\n            data=placeholder_data,\n            plugin=self\n        )\n        # Add transient data for easier access\n        item.transient_data = {\n            \"node\": placeholder_node\n        }\n\n        return item\n\n    @lib.undo_chunk(\"Update placeholder\")\n    def update_placeholder(self,\n                           placeholder_item: PlaceholderItem,\n                           placeholder_data: dict):\n        node = placeholder_item.transient_data[\"node\"]  # noqa\n        placeholder_data[\"plugin_identifier\"] = self.identifier\n        imprint(node, placeholder_data, key=self.data_key)\n\n    def _collect_placeholder_nodes(self) -&gt; Dict[str, List[fx.Node]]:\n        nodes = self.builder.get_shared_populate_data(\"placeholder_nodes\")\n        if nodes is None:\n            # Populate cache\n            session = fx.activeSession()\n            project = fx.activeProject()\n            nodes_by_plugin_identifier = {}\n            for node in itertools.chain(session.nodes, project.sources):\n                node_data = read(node, key=self.data_key)\n                if not node_data:\n                    continue\n\n                plugin_identifier = node_data.get(\"plugin_identifier\")\n                if not plugin_identifier:\n                    continue\n\n                nodes_by_plugin_identifier.setdefault(\n                    plugin_identifier, []).append(node)\n\n            nodes = nodes_by_plugin_identifier\n            self.builder.set_shared_populate_data(\"placeholder_nodes\",\n                                                  nodes_by_plugin_identifier)\n\n        return nodes\n\n    def collect_placeholders(self) -&gt; List[PlaceholderItem]:\n        nodes_by_identifier = self._collect_placeholder_nodes()\n\n        placeholder_items = []\n        for node in nodes_by_identifier.get(self.identifier, []):\n            data = self._parse_placeholder_node_data(node)\n            placeholder_item = self.item_class(\n                scene_identifier=node.id,\n                data=data,\n                plugin=self)\n\n            # Add transient data for easier access\n            placeholder_item.transient_data = {\n                \"node\": node\n            }\n            placeholder_items.append(placeholder_item)\n\n        return placeholder_items\n\n    def _parse_placeholder_node_data(self, node) -&gt; dict:\n        return read(node, key=self.data_key)\n\n    @lib.undo_chunk(\"Delete placeholder\")\n    def delete_placeholder(self, placeholder: PlaceholderItem):\n        \"\"\"Remove placeholder if building was successful\"\"\"\n        node = placeholder.transient_data[\"node\"]  # noqa\n        if isinstance(node, fx.Node):\n            session = node.session\n            session.removeNode(node)\n        elif isinstance(node, fx.Source):\n            project = node.parent.parent  # Source -&gt; SourceItem -&gt; Project\n            project.removeItem(node)\n        else:\n            raise TypeError(f\"Unsupported placeholder node: {node}\")\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/workfile_template_builder.html#client.ayon_silhouette.api.workfile_template_builder.SilhouettePlaceholderPlugin.delete_placeholder","title":"<code>delete_placeholder(placeholder)</code>","text":"<p>Remove placeholder if building was successful</p> Source code in <code>client/ayon_silhouette/api/workfile_template_builder.py</code> <pre><code>@lib.undo_chunk(\"Delete placeholder\")\ndef delete_placeholder(self, placeholder: PlaceholderItem):\n    \"\"\"Remove placeholder if building was successful\"\"\"\n    node = placeholder.transient_data[\"node\"]  # noqa\n    if isinstance(node, fx.Node):\n        session = node.session\n        session.removeNode(node)\n    elif isinstance(node, fx.Source):\n        project = node.parent.parent  # Source -&gt; SourceItem -&gt; Project\n        project.removeItem(node)\n    else:\n        raise TypeError(f\"Unsupported placeholder node: {node}\")\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/workfile_template_builder.html#client.ayon_silhouette.api.workfile_template_builder.SilhouetteTemplateBuilder","title":"<code>SilhouetteTemplateBuilder</code>","text":"<p>               Bases: <code>AbstractTemplateBuilder</code></p> <p>Concrete implementation of AbstractTemplateBuilder for Silhouette</p> Source code in <code>client/ayon_silhouette/api/workfile_template_builder.py</code> <pre><code>class SilhouetteTemplateBuilder(AbstractTemplateBuilder):\n    \"\"\"Concrete implementation of AbstractTemplateBuilder for Silhouette\"\"\"\n\n    def import_template(self, path):\n        \"\"\"Import template into current scene.\n        Block if a template is already loaded.\n\n        Args:\n            path (str): A path to current template (usually given by\n            get_template_preset implementation)\n\n        Returns:\n            bool: Whether the template was successfully imported or not\n        \"\"\"\n        # TODO check if the template is already imported\n        lib.import_project(path)\n\n        # Clear any selection if it occurred on load or import\n        fx.select([])\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/api/workfile_template_builder.html#client.ayon_silhouette.api.workfile_template_builder.SilhouetteTemplateBuilder.import_template","title":"<code>import_template(path)</code>","text":"<p>Import template into current scene. Block if a template is already loaded.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>A path to current template (usually given by</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the template was successfully imported or not</p> Source code in <code>client/ayon_silhouette/api/workfile_template_builder.py</code> <pre><code>def import_template(self, path):\n    \"\"\"Import template into current scene.\n    Block if a template is already loaded.\n\n    Args:\n        path (str): A path to current template (usually given by\n        get_template_preset implementation)\n\n    Returns:\n        bool: Whether the template was successfully imported or not\n    \"\"\"\n    # TODO check if the template is already imported\n    lib.import_project(path)\n\n    # Clear any selection if it occurred on load or import\n    fx.select([])\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/create/create_matte_shapes.html","title":"create_matte_shapes","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/create/create_matte_shapes.html#client.ayon_silhouette.plugins.create.create_matte_shapes.CreateMatteShapes","title":"<code>CreateMatteShapes</code>","text":"<p>               Bases: <code>SilhouetteCreator</code></p> <p>Matte Shapes</p> Source code in <code>client/ayon_silhouette/plugins/create/create_matte_shapes.py</code> <pre><code>class CreateMatteShapes(plugin.SilhouetteCreator):\n    \"\"\"Matte Shapes\"\"\"\n\n    identifier = \"io.ayon.creators.silhouette.matteshapes\"\n    label = \"Matte Shapes\"\n    description = __doc__\n    product_type = \"matteshapes\"\n    icon = \"cubes\"\n\n    create_node_type = \"RotoNode\"\n\n    def get_attr_defs_for_instance(self, instance):\n        node = instance.transient_data[\"instance_node\"]\n        items = [\n            {\"label\": label, \"value\": shape.id}\n            for shape, label in lib.iter_children(node)\n            if isinstance(shape, fx.Shape)\n        ]\n        if not items:\n            items.append({\n                \"label\": \"&lt;No shapes found&gt;\",\n                \"value\": None\n            })\n\n        attr_defs = [\n            EnumDef(\n                \"shapes\",\n                label=\"Export shapes\",\n                items=items,\n                tooltip=\"Select shapes to include in matte shapes output. If \"\n                        \"none are selected then all shapes will be included.\",\n                multiselection=True,\n            )\n        ]\n\n        return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/create/create_render.html","title":"create_render","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/create/create_render.html#client.ayon_silhouette.plugins.create.create_render.CreateRender","title":"<code>CreateRender</code>","text":"<p>               Bases: <code>SilhouetteCreator</code></p> <p>Render Output</p> Source code in <code>client/ayon_silhouette/plugins/create/create_render.py</code> <pre><code>class CreateRender(plugin.SilhouetteCreator):\n    \"\"\"Render Output\"\"\"\n\n    identifier = \"io.ayon.creators.silhouette.render\"\n    label = \"Render\"\n    description = __doc__\n    product_type = \"render\"\n    icon = \"eye\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        with lib.undo_chunk(\"Create Render\"):\n            instance = super().create(\n                product_name, instance_data, pre_create_data)\n\n            # Set default render output path\n            # TODO: Make this configurable in settings\n            instance_node = instance.transient_data[\"instance_node\"]\n            instance_node.path.value = (\n                \"$(AYON_WORKDIR)/renders/silhouette/\"\n                f\"{product_name}/{product_name}\"\n            )\n\n    def get_instance_attr_defs(self):\n        return lib.collect_animation_defs(self.create_context)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/create/create_track_points.html","title":"create_track_points","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/create/create_track_points.html#client.ayon_silhouette.plugins.create.create_track_points.CreateTrackPoints","title":"<code>CreateTrackPoints</code>","text":"<p>               Bases: <code>SilhouetteCreator</code></p> <p>Track Points</p> Source code in <code>client/ayon_silhouette/plugins/create/create_track_points.py</code> <pre><code>class CreateTrackPoints(plugin.SilhouetteCreator):\n    \"\"\"Track Points\"\"\"\n\n    identifier = \"io.ayon.creators.silhouette.trackpoints\"\n    label = \"Track Points\"\n    description = __doc__\n    product_type = \"trackpoints\"\n    icon = \"cubes\"\n\n    create_node_type = \"TrackerNode\"\n    valid_node_types = {\"TrackerNode\", \"RotoNode\"}\n\n    def get_attr_defs_for_instance(self, instance):\n        node = instance.transient_data[\"instance_node\"]\n        items = [\n            {\"label\": label, \"value\": tracker.id}\n            for tracker, label in lib.iter_children(node)\n            if isinstance(tracker, fx.Tracker)\n        ]\n        if not items:\n            items.append({\n                \"label\": \"&lt;No trackers found&gt;\",\n                \"value\": None\n            })\n\n        attr_defs = [\n            EnumDef(\n                \"trackers\",\n                label=\"Export trackers\",\n                items=items,\n                tooltip=\"Select trackers to include in output. If none are\"\n                        \" selected then all trackers will be included.\",\n                multiselection=True,\n            )\n        ]\n\n        return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/create/create_workfile.html","title":"create_workfile","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/create/create_workfile.html#client.ayon_silhouette.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_silhouette/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    identifier = \"io.ayon.creators.silhouette.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    project_property_name = \"AYON_workfile\"\n    default_variant = \"Main\"\n\n    def create(self):\n        \"\"\"Create workfile instances.\"\"\"\n        if not fx.activeProject():\n            return\n\n        workfile_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ),\n            None,\n        )\n\n        project_entity = self.create_context.get_current_project_entity()\n        project_name = project_entity[\"name\"]\n        folder_entity = self.create_context.get_current_folder_entity()\n        folder_path = folder_entity[\"path\"]\n        task_entity = self.create_context.get_current_task_entity()\n        task_name = task_entity[\"name\"]\n        host_name = self.create_context.host_name\n\n        variant = self.default_variant\n        if not workfile_instance:\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n                project_entity=project_entity\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": variant,\n            }\n\n            data.update(\n                self.get_dynamic_data(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    variant,\n                    host_name,\n                    workfile_instance,\n                )\n            )\n            self.log.info(\"Auto-creating workfile instance...\")\n            workfile_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(workfile_instance)\n\n        elif (\n            workfile_instance[\"folderPath\"] != folder_path\n            or workfile_instance[\"task\"] != task_name\n        ):\n            # Update instance context if it's different\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n                instance=workfile_instance,\n                project_entity=project_entity\n            )\n\n            workfile_instance[\"folderPath\"] = folder_path\n            workfile_instance[\"task\"] = task_name\n            workfile_instance[\"productName\"] = product_name\n\n        workfile_instance.transient_data[\"project\"] = fx.activeProject()\n\n    def collect_instances(self):\n\n        project = fx.activeProject()\n        if not project:\n            return\n\n        data = lib.read(project, key=self.project_property_name)\n        if not data:\n            return\n\n        data[\"instance_id\"] = project.id + \"_workfile\"\n\n        # Add instance\n        created_instance = CreatedInstance.from_existing(data, self)\n\n        # Collect transient data\n        created_instance.transient_data[\"project\"] = project\n\n        # Add instance to create context\n        self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n            project = created_inst.transient_data[\"project\"]\n            new_data = created_inst.data_to_store()\n            new_data.pop(\"instance_id\", None)\n            lib.imprint(project, new_data, key=self.project_property_name)\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            project = instance.transient_data[\"project\"]\n            lib.imprint(project, data=None, key=self.project_property_name)\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/create/create_workfile.html#client.ayon_silhouette.plugins.create.create_workfile.CreateWorkfile.create","title":"<code>create()</code>","text":"<p>Create workfile instances.</p> Source code in <code>client/ayon_silhouette/plugins/create/create_workfile.py</code> <pre><code>def create(self):\n    \"\"\"Create workfile instances.\"\"\"\n    if not fx.activeProject():\n        return\n\n    workfile_instance = next(\n        (\n            instance for instance in self.create_context.instances\n            if instance.creator_identifier == self.identifier\n        ),\n        None,\n    )\n\n    project_entity = self.create_context.get_current_project_entity()\n    project_name = project_entity[\"name\"]\n    folder_entity = self.create_context.get_current_folder_entity()\n    folder_path = folder_entity[\"path\"]\n    task_entity = self.create_context.get_current_task_entity()\n    task_name = task_entity[\"name\"]\n    host_name = self.create_context.host_name\n\n    variant = self.default_variant\n    if not workfile_instance:\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n            project_entity=project_entity\n        )\n        data = {\n            \"folderPath\": folder_path,\n            \"task\": task_name,\n            \"variant\": variant,\n        }\n\n        data.update(\n            self.get_dynamic_data(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n                workfile_instance,\n            )\n        )\n        self.log.info(\"Auto-creating workfile instance...\")\n        workfile_instance = CreatedInstance(\n            self.product_type, product_name, data, self\n        )\n        self._add_instance_to_context(workfile_instance)\n\n    elif (\n        workfile_instance[\"folderPath\"] != folder_path\n        or workfile_instance[\"task\"] != task_name\n    ):\n        # Update instance context if it's different\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n            instance=workfile_instance,\n            project_entity=project_entity\n        )\n\n        workfile_instance[\"folderPath\"] = folder_path\n        workfile_instance[\"task\"] = task_name\n        workfile_instance[\"productName\"] = product_name\n\n    workfile_instance.transient_data[\"project\"] = fx.activeProject()\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/load/actions.html","title":"actions","text":"<p>A module containing generic loader actions that will display in the Loader.</p>"},{"location":"autoapi/client/ayon_silhouette/plugins/load/actions.html#client.ayon_silhouette.plugins.load.actions.SetFrameRangeLoader","title":"<code>SetFrameRangeLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range excluding pre- and post-handles</p> Source code in <code>client/ayon_silhouette/plugins/load/actions.py</code> <pre><code>class SetFrameRangeLoader(load.LoaderPlugin):\n    \"\"\"Set frame range excluding pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"pointcache\",\n        \"vdbcache\",\n        \"usd\",\n        \"render\",\n        \"plate\",\n        \"mayaScene\",\n        \"review\"\n    }\n    representations = {\"*\"}\n\n    label = \"Set frame range\"\n    order = 11\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name=None, namespace=None, options=None):\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        frame_start = version_attributes.get(\"frameStart\")\n        frame_end = version_attributes.get(\"frameEnd\")\n        if frame_start is None or frame_end is None:\n            print(\n                \"Skipping setting frame range because start or \"\n                \"end frame data is missing..\"\n            )\n            return\n\n        fps = version_attributes[\"fps\"]\n        _set_frame_range(frame_start, frame_end, fps)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/load/actions.html#client.ayon_silhouette.plugins.load.actions.SetFrameRangeWithHandlesLoader","title":"<code>SetFrameRangeWithHandlesLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range including pre- and post-handles</p> Source code in <code>client/ayon_silhouette/plugins/load/actions.py</code> <pre><code>class SetFrameRangeWithHandlesLoader(load.LoaderPlugin):\n    \"\"\"Set frame range including pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"pointcache\",\n        \"vdbcache\",\n        \"usd\",\n        \"render\",\n        \"plate\",\n        \"mayaScene\",\n        \"review\"\n    }\n    representations = {\"*\"}\n\n    label = \"Set frame range (with handles)\"\n    order = 12\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name=None, namespace=None, options=None):\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        frame_start = version_attributes.get(\"frameStart\")\n        frame_end = version_attributes.get(\"frameEnd\")\n        if frame_start is None or frame_end is None:\n            print(\n                \"Skipping setting frame range because start or \"\n                \"end frame data is missing..\"\n            )\n            return\n\n        # Include handles\n        frame_start -= version_attributes.get(\"handleStart\", 0)\n        frame_end += version_attributes.get(\"handleEnd\", 0)\n\n        fps = version_attributes[\"fps\"]\n        _set_frame_range(frame_start, frame_end, fps)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/load/load_shapes.html","title":"load_shapes","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/load/load_source.html","title":"load_source","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/load/load_source.html#client.ayon_silhouette.plugins.load.load_source.SourceLoader","title":"<code>SourceLoader</code>","text":"<p>               Bases: <code>SilhouetteLoader</code></p> <p>Load media source.</p> Source code in <code>client/ayon_silhouette/plugins/load/load_source.py</code> <pre><code>class SourceLoader(plugin.SilhouetteLoader):\n    \"\"\"Load media source.\"\"\"\n\n    color = \"orange\"\n    product_types = {\"*\"}\n    icon = \"code-fork\"\n    label = \"Load Source\"\n    order = -10\n    representations = {\"*\"}\n    extensions = {\n        ext.lstrip(\".\") for ext in VIDEO_EXTENSIONS.union(IMAGE_EXTENSIONS)\n    }\n\n    @lib.undo_chunk(\"Load Source\")\n    def load(self, context, name=None, namespace=None, options=None):\n        project = fx.activeProject()\n        if not project:\n            raise RuntimeError(\"No active project found.\")\n\n        filepath = self.filepath_from_context(context)\n\n        # Add Source item to the project\n        source = fx.Source(filepath)\n\n        # Provide a nice label indicating the product\n        source.label = self._get_label(context)\n        project.addItem(source)\n\n        # property.hidden = True  # hide the attribute\n        lib.imprint(source, data={\n            \"name\": str(name),\n            \"namespace\": str(namespace),\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n        })\n\n        # container = pipeline.containerise(\n        #     name=str(name),\n        #     namespace=str(namespace),\n        #     nodes=nodes,\n        #     context=context,\n        #     loader=str(self.__class__.__name__),\n        # )\n\n    def filepath_from_context(self, context):\n        # If the media is a sequence of files we need to load it with the\n        # frames in the path as in file.[start-end].ext\n        if context[\"representation\"][\"context\"].get(\"frame\"):\n            anatomy = Anatomy(\n                project_name=context[\"project\"][\"name\"],\n                project_entity=context[\"project\"]\n            )\n            representation = context[\"representation\"]\n            files = [data[\"path\"] for data in representation[\"files\"]]\n            files = [anatomy.fill_root(file) for file in files]\n\n            collections, _remainder = clique.assemble(\n                files, patterns=[clique.PATTERNS[\"frames\"]]\n            )\n            collection = collections[0]\n            frames = list(collection.indexes)\n            start = str(frames[0]).zfill(collection.padding)\n            end = str(frames[-1]).zfill(collection.padding)\n            return collection.format(f\"{{head}}[{start}-{end}]{{tail}}\")\n\n        return super().filepath_from_context(context)\n\n    def _get_label(self, context):\n        return context[\"product\"][\"name\"]\n\n    @lib.undo_chunk(\"Update Source\")\n    def update(self, container, context):\n        # Update filepath\n        item = container[\"_item\"]\n        item.property(\"path\").value = self.filepath_from_context(context)\n\n        # Update representation id\n        data = lib.read(item)\n        data[\"representation\"] = context[\"representation\"][\"id\"]\n        lib.imprint(item, data)\n\n    @lib.undo_chunk(\"Remove container\")\n    def remove(self, container):\n        \"\"\"Remove all sub containers\"\"\"\n        item = container[\"_item\"]\n        project = container[\"_project\"]\n        project.removeItem(item)\n\n    def switch(self, container, context):\n        \"\"\"Support switch to another representation.\"\"\"\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/load/load_source.html#client.ayon_silhouette.plugins.load.load_source.SourceLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove all sub containers</p> Source code in <code>client/ayon_silhouette/plugins/load/load_source.py</code> <pre><code>@lib.undo_chunk(\"Remove container\")\ndef remove(self, container):\n    \"\"\"Remove all sub containers\"\"\"\n    item = container[\"_item\"]\n    project = container[\"_project\"]\n    project.removeItem(item)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/load/load_source.html#client.ayon_silhouette.plugins.load.load_source.SourceLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Support switch to another representation.</p> Source code in <code>client/ayon_silhouette/plugins/load/load_source.py</code> <pre><code>def switch(self, container, context):\n    \"\"\"Support switch to another representation.\"\"\"\n    self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/load/load_trackpoints.html","title":"load_trackpoints","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/load/load_trackpoints.html#client.ayon_silhouette.plugins.load.load_trackpoints.TrackPointsLoader","title":"<code>TrackPointsLoader</code>","text":"<p>               Bases: <code>SilhouetteImportLoader</code></p> <p>Load track points.</p> Source code in <code>client/ayon_silhouette/plugins/load/load_trackpoints.py</code> <pre><code>class TrackPointsLoader(plugin.SilhouetteImportLoader):\n    \"\"\"Load track points.\"\"\"\n\n    color = \"orange\"\n    product_types = {\"trackpoints\"}\n    icon = \"code-fork\"\n    label = \"Load Trackers\"\n    order = -5\n    representations = {\"*\"}\n    extensions = {\"txt\"}\n\n    io_module = \"After Effects Corner-Pin\"\n    # TODO: Support \"Nuke\"           # .nk\n    # TODO: Support \"Nuke 5\"         # .nk\n    # TODO: Support \"Shake\"          # .txt\n    # TODO: Support \"Simple Format\"  # .txt\n\n    def can_import_to_node(self, node) -&gt; bool:\n        if not super().can_import_to_node(node):\n            return False\n\n        return node.supportsChildType(\"Tracker\")\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/collect_current_document.html","title":"collect_current_document","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/collect_current_document.html#client.ayon_silhouette.plugins.publish.collect_current_document.CollectSilhouetteActiveDocument","title":"<code>CollectSilhouetteActiveDocument</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the active project and session</p> Source code in <code>client/ayon_silhouette/plugins/publish/collect_current_document.py</code> <pre><code>class CollectSilhouetteActiveDocument(pyblish.api.ContextPlugin):\n    \"\"\"Inject the active project and session\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Silhouette Active Project\"\n    hosts = ['silhouette']\n\n    def process(self, context):\n\n        project = fx.activeProject()\n        session = fx.activeSession()\n        if not project:\n            self.log.warning(\"No active project found.\")\n        if not session:\n            self.log.warning(\"No active session found.\")\n\n        context.data[\"silhouetteProject\"] = project\n        context.data[\"silhouetteSession\"] = session\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/collect_current_file.html#client.ayon_silhouette.plugins.publish.collect_current_file.CollectSilhouetteCurrentFile","title":"<code>CollectSilhouetteCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file into context</p> Source code in <code>client/ayon_silhouette/plugins/publish/collect_current_file.py</code> <pre><code>class CollectSilhouetteCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Silhouette Current File\"\n    hosts = [\"silhouette\"]\n\n    def process(self, context):\n        \"\"\"Inject the current working file\"\"\"\n        host = registered_host()\n        current_file = host.get_current_workfile()\n        context.data['currentFile'] = current_file\n        if not current_file:\n            self.log.warning(\n                \"Current file is not saved. Save the file before continuing.\"\n            )\n        else:\n            self.log.debug(f\"Current file: {current_file}\")\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/collect_current_file.html#client.ayon_silhouette.plugins.publish.collect_current_file.CollectSilhouetteCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file</p> Source code in <code>client/ayon_silhouette/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file\"\"\"\n    host = registered_host()\n    current_file = host.get_current_workfile()\n    context.data['currentFile'] = current_file\n    if not current_file:\n        self.log.warning(\n            \"Current file is not saved. Save the file before continuing.\"\n        )\n    else:\n        self.log.debug(f\"Current file: {current_file}\")\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/collect_instances.html","title":"collect_instances","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/collect_workfile.html#client.ayon_silhouette.plugins.publish.collect_workfile.CollectWorkfileData","title":"<code>CollectWorkfileData</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Inject project data into Workfile instance</p> Source code in <code>client/ayon_silhouette/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfileData(pyblish.api.InstancePlugin):\n    \"\"\"Inject project data into Workfile instance\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.01\n    label = \"Silhouette Workfile\"\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        \"\"\"Inject the current working file data\"\"\"\n        context = instance.context\n        instance.data.update({\n            \"frameStart\": context.data[\"frameStart\"],\n            \"frameEnd\": context.data[\"frameEnd\"],\n            \"handleStart\": context.data[\"handleStart\"],\n            \"handleEnd\": context.data[\"handleEnd\"]\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/collect_workfile.html#client.ayon_silhouette.plugins.publish.collect_workfile.CollectWorkfileData.process","title":"<code>process(instance)</code>","text":"<p>Inject the current working file data</p> Source code in <code>client/ayon_silhouette/plugins/publish/collect_workfile.py</code> <pre><code>def process(self, instance):\n    \"\"\"Inject the current working file data\"\"\"\n    context = instance.context\n    instance.data.update({\n        \"frameStart\": context.data[\"frameStart\"],\n        \"frameEnd\": context.data[\"frameEnd\"],\n        \"handleStart\": context.data[\"handleStart\"],\n        \"handleEnd\": context.data[\"handleEnd\"]\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_render.html","title":"extract_render","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_shapes.html","title":"extract_shapes","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_shapes.html#client.ayon_silhouette.plugins.publish.extract_shapes.ExtractFusionShapes","title":"<code>ExtractFusionShapes</code>","text":"<p>               Bases: <code>ExtractNukeShapes</code></p> <p>Extract node as Fusion Shapes.</p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_shapes.py</code> <pre><code>class ExtractFusionShapes(ExtractNukeShapes):\n    \"\"\"Extract node as Fusion Shapes.\"\"\"\n    # TODO: Suppress a pop-up dialog\n    families = [\"matteshapes\"]\n    label = \"Extract Fusion Shapes\"\n    extension = \"setting\"\n    io_module = \"Fusion Shapes\"\n\n    capture_messageboxes = True\n\n    def on_captured_messagebox(self, messagebox):\n        # Suppress pop-up dialogs\n        self.log.debug(f\"Detected messagebox: {messagebox.text()}\")\n\n        def click(messagebox: QtWidgets.QMessageBox, text: str):\n            \"\"\"Click QMessageBox button with matching text.\"\"\"\n            self.log.debug(f\"Accepting messagebox with '{text}'\")\n            button = next(\n                button for button in messagebox.buttons()\n                if button.text() == text\n            )\n            button.click()\n\n        messagebox_text = messagebox.text()\n        if messagebox_text == \"Output Fusion Groups?\":\n            click(messagebox, \"&amp;Yes\")\n        elif messagebox_text == \"Link Shapes?\":\n            click(messagebox, \"&amp;Yes\")\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_shapes.html#client.ayon_silhouette.plugins.publish.extract_shapes.ExtractNuke62Shapes","title":"<code>ExtractNuke62Shapes</code>","text":"<p>               Bases: <code>ExtractNukeShapes</code></p> <p>Extract node as Nuke 6.2+ Shapes.</p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_shapes.py</code> <pre><code>class ExtractNuke62Shapes(ExtractNukeShapes):\n    \"\"\"Extract node as Nuke 6.2+ Shapes.\"\"\"\n    families = [\"matteshapes\"]\n    label = \"Extract Nuke 6.2+ Shapes\"\n    io_module = \"Nuke 6.2+ Shapes\"\n\n    # Use nk62 name to avoid conflicts with the nuke 9+ shapes output\n    override_name = \"nk62\"\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_shapes.html#client.ayon_silhouette.plugins.publish.extract_shapes.ExtractNukeShapes","title":"<code>ExtractNukeShapes</code>","text":"<p>               Bases: <code>Extractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract node as Nuke 9+ Shapes.</p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_shapes.py</code> <pre><code>class ExtractNukeShapes(publish.Extractor,\n                        publish.OptionalPyblishPluginMixin):\n    \"\"\"Extract node as Nuke 9+ Shapes.\"\"\"\n\n    label = \"Extract Nuke 9+ Shapes\"\n    hosts = [\"silhouette\"]\n    families = [\"matteshapes\"]\n\n    extension = \"nk\"\n    io_module = \"Nuke 9+ Shapes\"\n\n    # When set, override the representation name and `outputName`\n    override_name: Optional[str] = None\n\n    settings_category = \"silhouette\"\n\n    capture_messageboxes = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        dir_path = self.staging_dir(instance)\n        filename = \"{0}.{1}\".format(instance.name, self.extension)\n        path = os.path.join(dir_path, filename)\n\n        node = instance.data[\"transientData\"][\"instance_node\"]\n\n        # Use selection, if any specified, otherwise use all children shapes\n        shape_ids = instance.data.get(\"creator_attributes\", {}).get(\"shapes\")\n        if shape_ids:\n            shapes = [fx.findObject(shape_id) for shape_id in shape_ids]\n        else:\n            shapes = [\n                shape for shape, _label in lib.iter_children(node)\n                if isinstance(shape, fx.Shape)\n            ]\n\n        with lib.maintained_selection():\n            fx.select(shapes)\n            with contextlib.ExitStack() as stack:\n                self.log.debug(f\"Exporting '{self.io_module}' to: {path}\")\n                if self.capture_messageboxes:\n                    stack.enter_context(\n                        lib.capture_messageboxes(self.on_captured_messagebox))\n                fx.io_modules[self.io_module].export(path)\n\n        representation = {\n            \"name\": self.override_name or self.extension,\n            \"ext\": self.extension,\n            \"files\": filename,\n            \"stagingDir\": dir_path,\n        }\n        if self.override_name:\n            representation[\"outputName\"] = self.override_name\n        instance.data.setdefault(\"representations\", []).append(representation)\n\n        self.log.debug(f\"Extracted instance '{instance.name}' to: {path}\")\n\n    def on_captured_messagebox(self, messagebox: QtWidgets.QMessageBox):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_shapes.html#client.ayon_silhouette.plugins.publish.extract_shapes.ExtractShakeShapes","title":"<code>ExtractShakeShapes</code>","text":"<p>               Bases: <code>ExtractNukeShapes</code></p> <p>Extract node as Shake Shapes.</p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_shapes.py</code> <pre><code>class ExtractShakeShapes(ExtractNukeShapes):\n    \"\"\"Extract node as Shake Shapes.\"\"\"\n    families = [\"matteshapes\"]\n    label = \"Extract Shape Shapes\"\n    extension = \"ssf\"\n    io_module = \"Shake 4.x SSF\"\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_shapes.html#client.ayon_silhouette.plugins.publish.extract_shapes.ExtractSilhouetteShapes","title":"<code>ExtractSilhouetteShapes</code>","text":"<p>               Bases: <code>ExtractNukeShapes</code></p> <p>Extract node as Silhouette Shapes.</p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_shapes.py</code> <pre><code>class ExtractSilhouetteShapes(ExtractNukeShapes):\n    \"\"\"Extract node as Silhouette Shapes.\"\"\"\n    families = [\"matteshapes\"]\n    label = \"Extract Silhouette Shapes\"\n    extension = \"fxs\"\n    io_module = \"Silhouette Shapes\"\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_track.html","title":"extract_track","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_track.html#client.ayon_silhouette.plugins.publish.extract_track.SilhouetteExtractAfterEffectsTrack","title":"<code>SilhouetteExtractAfterEffectsTrack</code>","text":"<p>               Bases: <code>Extractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract After Effects .txt track from Silhouette.</p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_track.py</code> <pre><code>class SilhouetteExtractAfterEffectsTrack(publish.Extractor,\n                                         publish.OptionalPyblishPluginMixin):\n    \"\"\"Extract After Effects .txt track from Silhouette.\"\"\"\n    label = \"Extract After Effects .txt\"\n    hosts = [\"silhouette\"]\n    families = [\"trackpoints\"]\n\n    extension = \"txt\"\n    io_module = \"After Effects\"\n\n    settings_category = \"silhouette\"\n\n    capture_messageboxes = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        dir_path = self.staging_dir(instance)\n        filename = \"{0}.{1}\".format(instance.name, self.extension)\n        path = os.path.join(dir_path, filename)\n\n        # Node should be a node that contains 'tracker' children\n        node = instance.data[\"transientData\"][\"instance_node\"]\n\n        # Use selection, if any specified, otherwise use all children shapes\n        tracker_ids = instance.data.get(\n            \"creator_attributes\", {}).get(\"trackers\")\n        if tracker_ids:\n            trackers = [\n                fx.findObject(tracker_id) for tracker_id in tracker_ids\n            ]\n        else:\n            trackers = [\n                tracker for tracker, _label in lib.iter_children(node)\n                if isinstance(tracker, fx.Tracker)\n            ]\n\n        with lib.maintained_selection():\n            fx.select(trackers)\n            with contextlib.ExitStack() as stack:\n                self.log.debug(f\"Exporting '{self.io_module}' to: {path}\")\n                if self.capture_messageboxes:\n                    stack.enter_context(\n                        lib.capture_messageboxes(self.on_captured_messagebox))\n                fx.io_modules[self.io_module].export(path)\n\n        representation = {\n            \"name\": self.extension,\n            \"ext\": self.extension,\n            \"files\": filename,\n            \"stagingDir\": dir_path,\n        }\n        instance.data.setdefault(\"representations\", []).append(representation)\n\n        self.log.debug(f\"Extracted instance '{instance.name}' to: {path}\")\n\n    def on_captured_messagebox(self, messagebox: QtWidgets.QMessageBox):\n        self.log.debug(f\"Detected messagebox: {messagebox.text()}\")\n        button_texts = [button.text() for button in messagebox.buttons()]\n        self.log.debug(f\"Buttons: {button_texts}\")\n        # Continue if messagebox is just confirmation dialog about After\n        # Effects being unable to keyframe Match Size, Search Offset and Search\n        # Size.\n        if \"After Effects cannot keyframe\" in messagebox.text():\n            self.click(messagebox, \"&amp;Yes\")\n\n    def click(self, messagebox: QtWidgets.QMessageBox, text: str):\n        \"\"\"Click QMessageBox button with matching text.\"\"\"\n        self.log.debug(f\"Accepting messagebox with '{text}'\")\n        button = next(\n            button for button in messagebox.buttons()\n            if button.text() == text\n        )\n        button.click()\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_track.html#client.ayon_silhouette.plugins.publish.extract_track.SilhouetteExtractAfterEffectsTrack.click","title":"<code>click(messagebox, text)</code>","text":"<p>Click QMessageBox button with matching text.</p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_track.py</code> <pre><code>def click(self, messagebox: QtWidgets.QMessageBox, text: str):\n    \"\"\"Click QMessageBox button with matching text.\"\"\"\n    self.log.debug(f\"Accepting messagebox with '{text}'\")\n    button = next(\n        button for button in messagebox.buttons()\n        if button.text() == text\n    )\n    button.click()\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_track.html#client.ayon_silhouette.plugins.publish.extract_track.SilhouetteExtractNuke5Track","title":"<code>SilhouetteExtractNuke5Track</code>","text":"<p>               Bases: <code>SilhouetteExtractAfterEffectsTrack</code></p> <p>Extract Nuke 5 .nk trackers from Silhouette.</p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_track.py</code> <pre><code>class SilhouetteExtractNuke5Track(SilhouetteExtractAfterEffectsTrack):\n    \"\"\"Extract Nuke 5 .nk trackers from Silhouette.\"\"\"\n    label = \"Extract Nuke 5 Trackers\"\n    hosts = [\"silhouette\"]\n    families = [\"trackpoints\"]\n\n    extension = \"nk\"\n    io_module = \"Nuke 5\"\n\n    # Whether or not to merge up to four trackers in a single Nuke Tracker node\n    # or otherwise export as multiple single point tracker nodes\n    merge_up_to_four = True\n\n    def on_captured_messagebox(self, messagebox: QtWidgets.QMessageBox):\n        self.log.debug(f\"Detected messagebox: {messagebox.text()}\")\n        button_texts = [button.text() for button in messagebox.buttons()]\n        self.log.debug(f\"Buttons: {button_texts}\")\n        # Merge up to four tracker\n        if \"Select Yes to merge.\" in messagebox.text():\n            button = \"&amp;Yes\" if self.merge_up_to_four else \"&amp;No\"\n            self.click(messagebox, button)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_workfile.html","title":"extract_workfile","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_workfile.html#client.ayon_silhouette.plugins.publish.extract_workfile.SilhouetteExtractWorkfile","title":"<code>SilhouetteExtractWorkfile</code>","text":"<p>               Bases: <code>Extractor</code></p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_workfile.py</code> <pre><code>class SilhouetteExtractWorkfile(publish.Extractor):\n    label = \"Extract Workfile\"\n    hosts = [\"silhouette\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        \"\"\"Extract the current working file as .zip\"\"\"\n        # Note that Silhouette project workfiles are actually folders,\n        # not files.\n\n        current_file = instance.context.data[\"currentFile\"]\n        if not current_file:\n            raise publish.PublishError(\"No current file found in context\")\n\n        # Save current file\n        host = registered_host()\n        host.save_workfile()\n\n        # Zip current workfile (Silhouette workfiles are folders)\n        staging_dir = self.staging_dir(instance)\n        filename = f\"{instance.name}.zip\"\n        lib.zip_folder(current_file, os.path.join(staging_dir, filename))\n\n        # Add representation\n        instance.data.setdefault(\"representations\", []).append({\n            \"name\": \"sfx_zip\",\n            \"ext\": \"zip\",\n            \"files\": filename,\n            \"stagingDir\": staging_dir,\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/extract_workfile.html#client.ayon_silhouette.plugins.publish.extract_workfile.SilhouetteExtractWorkfile.process","title":"<code>process(instance)</code>","text":"<p>Extract the current working file as .zip</p> Source code in <code>client/ayon_silhouette/plugins/publish/extract_workfile.py</code> <pre><code>def process(self, instance):\n    \"\"\"Extract the current working file as .zip\"\"\"\n    # Note that Silhouette project workfiles are actually folders,\n    # not files.\n\n    current_file = instance.context.data[\"currentFile\"]\n    if not current_file:\n        raise publish.PublishError(\"No current file found in context\")\n\n    # Save current file\n    host = registered_host()\n    host.save_workfile()\n\n    # Zip current workfile (Silhouette workfiles are folders)\n    staging_dir = self.staging_dir(instance)\n    filename = f\"{instance.name}.zip\"\n    lib.zip_folder(current_file, os.path.join(staging_dir, filename))\n\n    # Add representation\n    instance.data.setdefault(\"representations\", []).append({\n        \"name\": \"sfx_zip\",\n        \"ext\": \"zip\",\n        \"files\": filename,\n        \"stagingDir\": staging_dir,\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/increment_current_file.html","title":"increment_current_file","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/increment_current_file.html#client.ayon_silhouette.plugins.publish.increment_current_file.IncrementCurrentFile","title":"<code>IncrementCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Increment the current file.</p> <p>Saves the current scene with an increased version number.</p> Source code in <code>client/ayon_silhouette/plugins/publish/increment_current_file.py</code> <pre><code>class IncrementCurrentFile(pyblish.api.ContextPlugin,\n                           OptionalPyblishPluginMixin):\n    \"\"\"Increment the current file.\n\n    Saves the current scene with an increased version number.\n    \"\"\"\n    label = \"Increment current file\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    families = [\"*\"]\n    hosts = [\"silhouette\"]\n    optional = True\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        # Filename must not have changed since collecting\n        host = registered_host()\n        current_file = host.current_file()\n        if context.data[\"currentFile\"] != current_file:\n            raise KnownPublishError(\n                \"Collected filename mismatches from current scene name.\"\n            )\n\n        new_filepath = version_up(current_file)\n        host.save_workfile(new_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/save_scene.html","title":"save_scene","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/save_scene.html#client.ayon_silhouette.plugins.publish.save_scene.SaveCurrentScene","title":"<code>SaveCurrentScene</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Save current scene</p> Source code in <code>client/ayon_silhouette/plugins/publish/save_scene.py</code> <pre><code>class SaveCurrentScene(pyblish.api.ContextPlugin):\n    \"\"\"Save current scene\"\"\"\n\n    label = \"Save current file\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    hosts = [\"silhouette\"]\n\n    def process(self, context):\n        host = registered_host()\n\n        # If file has no modifications, skip forcing a file save\n        if not host.workfile_has_unsaved_changes():\n            self.log.debug(\"Skipping file save as there \"\n                           \"are no unsaved changes..\")\n            return\n\n        # Filename must not have changed since collecting\n        current_file = host.get_current_workfile()\n        if context.data[\"currentFile\"] != current_file:\n            raise KnownPublishError(\n                \"Collected filename mismatches from current scene name.\"\n            )\n\n        self.log.debug(f\"Saving current file: {current_file}\")\n        host.save_workfile()\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/validate_shapes.html","title":"validate_shapes","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/validate_shapes.html#client.ayon_silhouette.plugins.publish.validate_shapes.ValidateShapes","title":"<code>ValidateShapes</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate shapes exist on node.</p> Source code in <code>client/ayon_silhouette/plugins/publish/validate_shapes.py</code> <pre><code>class ValidateShapes(pyblish.api.InstancePlugin):\n    \"\"\"Validate shapes exist on node.\"\"\"\n\n    label = \"Missing Shapes\"\n    hosts = [\"silhouette\"]\n    families = [\"matteshapes\"]\n    order = pyblish.api.ValidatorOrder\n\n    def process(self, instance):\n        # Node should be a node that contains 'shapes' children\n        node = instance.data[\"transientData\"][\"instance_node\"]\n        if not any(\n            shape for shape, _label in lib.iter_children(node)\n            if isinstance(shape, fx.Shape)\n        ):\n            raise publish.PublishValidationError(\n                \"No shapes found on node: {0}\".format(node.label)\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/publish/validate_trackers.html","title":"validate_trackers","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/publish/validate_trackers.html#client.ayon_silhouette.plugins.publish.validate_trackers.ValidateTrackers","title":"<code>ValidateTrackers</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate trackers exist on node.</p> Source code in <code>client/ayon_silhouette/plugins/publish/validate_trackers.py</code> <pre><code>class ValidateTrackers(pyblish.api.InstancePlugin):\n    \"\"\"Validate trackers exist on node.\"\"\"\n\n    label = \"Missing Trackers\"\n    hosts = [\"silhouette\"]\n    families = [\"trackpoints\"]\n    order = pyblish.api.ValidatorOrder\n\n    def process(self, instance):\n        # Node should be a node that contains 'tracker' children\n        node = instance.data[\"transientData\"][\"instance_node\"]\n        if not any(\n            tracker for tracker, _label in lib.iter_children(node)\n            if isinstance(tracker, fx.Tracker)\n        ):\n            raise publish.PublishValidationError(\n                \"No trackers found on node: {0}\".format(node.label)\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/workfile_build/index.html","title":"workfile_build","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/workfile_build/create_placeholder.html","title":"create_placeholder","text":""},{"location":"autoapi/client/ayon_silhouette/plugins/workfile_build/create_placeholder.html#client.ayon_silhouette.plugins.workfile_build.create_placeholder.SilhouettePlaceholderCreatePlugin","title":"<code>SilhouettePlaceholderCreatePlugin</code>","text":"<p>               Bases: <code>SilhouettePlaceholderPlugin</code>, <code>PlaceholderCreateMixin</code></p> Source code in <code>client/ayon_silhouette/plugins/workfile_build/create_placeholder.py</code> <pre><code>class SilhouettePlaceholderCreatePlugin(\n    SilhouettePlaceholderPlugin, PlaceholderCreateMixin\n):\n    identifier = \"silhouette.placeholder.create\"\n    label = \"Silhouette create\"\n\n    item_class = CreatePlaceholderItem\n\n    def populate_placeholder(self, placeholder):\n        self.populate_create_placeholder(placeholder)\n\n    def repopulate_placeholder(self, placeholder):\n        self.populate_create_placeholder(placeholder)\n\n    def get_placeholder_options(self, options=None):\n        return self.get_create_plugin_options(options)\n\n    def post_placeholder_process(self, placeholder, failed):\n        \"\"\"Cleanup placeholder after load of its corresponding representations.\n\n        Args:\n            placeholder (PlaceholderItem): Item which was just used to load\n                representation.\n            failed (bool): Loading of representation failed.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/workfile_build/create_placeholder.html#client.ayon_silhouette.plugins.workfile_build.create_placeholder.SilhouettePlaceholderCreatePlugin.post_placeholder_process","title":"<code>post_placeholder_process(placeholder, failed)</code>","text":"<p>Cleanup placeholder after load of its corresponding representations.</p> <p>Parameters:</p> Name Type Description Default <code>placeholder</code> <code>PlaceholderItem</code> <p>Item which was just used to load representation.</p> required <code>failed</code> <code>bool</code> <p>Loading of representation failed.</p> required Source code in <code>client/ayon_silhouette/plugins/workfile_build/create_placeholder.py</code> <pre><code>def post_placeholder_process(self, placeholder, failed):\n    \"\"\"Cleanup placeholder after load of its corresponding representations.\n\n    Args:\n        placeholder (PlaceholderItem): Item which was just used to load\n            representation.\n        failed (bool): Loading of representation failed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_silhouette/plugins/workfile_build/load_placeholder.html","title":"load_placeholder","text":""},{"location":"autoapi/client/ayon_silhouette/startup/index.html","title":"startup","text":""},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/publish.html","title":"publish","text":""},{"location":"autoapi/server/settings/templated_workfile_build.html","title":"templated_workfile_build","text":""},{"location":"autoapi/server/settings/templated_workfile_build.html#server.settings.templated_workfile_build.TemplatedWorkfileBuildModel","title":"<code>TemplatedWorkfileBuildModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for templated workfile builder.</p> Source code in <code>server/settings/templated_workfile_build.py</code> <pre><code>class TemplatedWorkfileBuildModel(BaseSettingsModel):\n    \"\"\"Settings for templated workfile builder.\"\"\"\n    profiles: list[TemplatedWorkfileProfileModel] = SettingsField(\n        default_factory=list\n    )\n</code></pre>"}]}